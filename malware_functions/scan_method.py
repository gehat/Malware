from PyQt5.uic.properties import QtWidgets

from malware_functions.connection_info import connection_pool


class Scanner():
    def quick_scan_function(self):
        from malware_functions.file_sc import scanning, process_file
        from malware_functions.logical_disc_name import List_Disk
        import multiprocessing
        lst_vir = []
        scan_count = 0
        cache_size = 20  # len files package
        cache_size_file = []  # files package
        try:
            with multiprocessing.Pool(processes=multiprocessing.cpu_count()) as p:
                # list_disk = List_Disk().list_logical_disk
                for j in scanning('C:'):
                    cache_size_file.append(j)
                    if len(cache_size_file) == cache_size:
                        scan_count += cache_size
                        if self.stop is False:

                            self.scan_path.setText(f'{cache_size_file[0][0][:44]}...{cache_size_file[-1][1]}')
                            self.scan_count_number.setText(f'{scan_count}')
                            result = p.map_async(process_file, (cache_size_file))
                            lst_vir.append(result.get())
                            cache_size_file = []

                        else:
                            if not connection_pool.closed:
                                connection_pool.closeall()
                                raise Exception
                # Process any remaining files in the batch
                if len(cache_size_file) > 0:
                    print(len(cache_size_file))
                    scan_count += len(cache_size_file)
                    print(scan_count)
                    if self.stop is False:
                        self.scan_path.setText(f'{cache_size_file[0][0][:44]}...{cache_size_file[-1][1]}')
                        self.scan_count_number.setText(f'{scan_count}')
                        result = p.map_async(process_file, cache_size_file)
                        lst_vir.append(result.get())
                    else:
                        if not connection_pool.closed:
                            connection_pool.closeall()
        except Exception as e:
            print("An error occurred: ", e)
        finally:
            if not connection_pool.closed:
                connection_pool.closeall()
            self.stop = False
            self.ongoing_2 = True
            return lst_vir

    def full_scan(self):
        import multiprocessing

        from malware_functions.file_sc import scanning, process_file
        from malware_functions.logical_disc_name import List_Disk
        scannin_count = 0
        list_disk = List_Disk().list_logical_disk
        lst=[]

        with multiprocessing.Pool(2) as p:
            try:
                for j in scanning('C:'):
                    if self.stop is False:
                        scannin_count += 1
                        self.scan_path.setText(f'{j[0][:44]}...{j[1]}')
                        self.scan_count_number.setText(str(scannin_count))
                        result = p.map_async(process_file, (j,))
                        lst.append(result.get())


                    else:
                        if not connection_pool.closed:
                            connection_pool.closeall()
                        raise Exception
                p.close()
                p.join()
            except Exception as e:
                print("An error occurred: ", e)

            finally:
                if not connection_pool.closed:
                    connection_pool.closeall()
                self.stop = False
                self.ongoing_1 = True
                return lst
